<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>Abusing Ruby 1.9 &amp; JSON for fun - CaiusTheory</title>

    <link rel="alternate" type="application/atom+xml" title="Caius Theory" href="/feed/" />

    <link rel="stylesheet" href="/stylesheets/stylesheet.css" type="text/css" media="screen" title="no title" charset="utf-8">
  </head>
  <body>

    <header>
      <h1><a href="/">Caius Theory</a></h1>
      <h2>Now with even more cowbell&hellip;</h2>
    </header>

    <main>
      <p>Ever since I found out about the new hash syntax you can use in ruby 1.9, and how similar that syntax is to JSON, I've been waiting for someone to realise you can just abuse <code>eval()</code> for parsing (some) JSON now.</p>

<p>For example, lets say we have the following ruby hash, which could be generated by a RESTful api:</p>

<pre><code>thing = {
    :person =&gt; {
        :name =&gt; "caius"
    }
}
</code></pre>

<p>If we pull in the JSON gem and dump that out as a string, we get the following:</p>

<pre><code>ruby-1.9.2-p136 &gt; jsonstr = thing.to_json
 =&gt; '{"person":{"name":"caius"}}'
</code></pre>

<p>That's… not quite what we wanted. It's not going to turn back into valid ruby as it is. Luckily javascript will parse objects without requiring the attributes to be wrapped in quotes, eg: <code>{some: "attribute"}</code>. We could build a JSON emitter that does it properly, or we could just run it through a regular expression instead. <em>(Lets also add a space after the colon to aid readability.)</em></p>

<pre><code>ruby-1.9.2-p136 &gt; jsonstr.gsub!(/"([^"]+)": /, '\1: ')
 =&gt; '{person: {name: "caius"}}'
</code></pre>

<p>Okay, so now we've turned a ruby hash into a JSON hash, that can still be parsed by the browser. Here's a screenshot to prove that:</p>

<p><img alt="Valid JSON 'thing'" src="http://farm6.static.flickr.com/5300/5425314597_43be5824cf_o.jpg" /></p>

<p>As you can see, it parses that into a valid JS object, complete with person and then (nested) name attributes. If we wanted to, <code>thing["person"]["name"]</code> or <code>thing.person.name</code> would access the nested value "caius" just fine.</p>

<p>Now then, we've proved that is successfully parsed into javascript objects by the browser, generated from a ruby hash. No great shakes there, that's fairly simple and has worked for ages. Now for my next trick, I'm going to turn that string of JSON back into a ruby hash, all without going anywhere near the JSON gem.</p>

<p>Some of you might have guessed what I'm about to do and have started hoping you've guessed wrongly — just for the record I don't condone doing this except for fun and games. The JSON gem is there for a reason ;) With that little disclaimer out the way, here we go!</p>

<pre><code>ruby-1.9.2-p136 &gt; thing2 = eval(jsonstr)
 =&gt; {:person=&gt;{:name=&gt;"caius"}}
ruby-1.9.2-p136 &gt; thing2 == thing
 =&gt; true
</code></pre>

<p>Oh snap! We just turned javascript objects back into valid ruby objects, in one simple method call. And we'd be able to access the "caius" value by calling <code>thing2[:person][:name]</code>, or creating OpenStructs from the hashes and calling <code>thing2.person.name</code>. Which is uncannily like the JS!</p>

<p><strong>Updated 2011-02-07</strong>: <a href="http://jens.ayton.se/">Jens Ayton</a> pointed out unquoted keys aren't strictly valid JSON, which is correct. Amended to say they're parsed as javascript objects instead, with no mention of it being valid JSON.</p>


    </main>

    <nav>
      <div class="archives">
        <h3>Archives</h3>
<!--        <ul>
            <li></li>
        </ul>
-->
      </div>

      <div class="feed">
        <link rel="alternate" type="application/rss+xml" title="Syndicate (atom)" href="/feed/" />
      </div>
    </nav>

    <span class="clear"></span>

    <footer>
      <p class="first">
        <a href="/">CaiusTheory</a>
      </p>
      <p class="last">
        Inspired by <a href="http://labs.utopian.net/habari/theme/sp/">sp</a>
      </p>
      <span class="clear"></span>
    </footer>
  </body>
</html>
